<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
    <title>:: Pardus :: TÜBİTAK/UEKAE ::</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link href="../../../../style.css" rel="stylesheet" type="text/css">
    <link rel="shortcut icon" type="image/x-icon" href="../../../../images/favicon.ico">
</head>
<body>
<div id="container">
    <div id="head_grey2">
        <div id="blue2">
		<map name="header_map">
		<area shape="rect" href="../../../index.html" coords="24,24,143,101" >
		<area shape="rect" href="../../../documents/HOWTO_install.html" coords="596,115,721,144" >
		<area shape="rect" href="../../../download.html" coords="596,26,721,105" >
		</map>
		<img src="../../../images/header.png" usemap="#header_map" width="740" height="163" border="0">
        </div>
    </div>
    <div id="navi">
        <a href="../../../index.html">Home</a>
      | <a href="../../../info.html">About</a>
      | <a href="../../../projects/index.html">Projects</a>
      | <a href="../../../documents/index.html">Documents</a>
      | <a href="../../../products/index.html">Products</a>
      | <a href="../../../contact.html">Contact Us</a>
      | <a href="../../../press/index.html">Press</a>
      | <a href="../../../../index.html">Türkçe</a>
    </div>
    <div id="page" class="blue2">
        <div id="fullpage">
<!-- SAYFA İÇERİK BAŞI -->
<div class="belge">


<H1 ALIGN=center>Uluslararasılaştırma</H1>

<!--TOC section İçindekiler-->

<H2>İçindekiler</H2><!--SEC END -->

<UL><LI>
<A HREF="#htoc1">1&nbsp;&nbsp;Yerel Sistemi</A>
<UL><LI>
<A HREF="#htoc2">1.1&nbsp;&nbsp;Kategoriler</A>
<LI><A HREF="#htoc3">1.2&nbsp;&nbsp;Yerel İsimleri</A>
<LI><A HREF="#htoc4">1.3&nbsp;&nbsp;Yerel Seçimi</A>
</UL>
<LI><A HREF="#htoc5">2&nbsp;&nbsp;UNICODE</A>
<UL><LI>
<A HREF="#htoc6">2.1&nbsp;&nbsp;UTF-8 (RFC 3629)</A>
<LI><A HREF="#htoc7">2.2&nbsp;&nbsp;UTF-16 (RFC 2781)</A>
</UL>
<LI><A HREF="#htoc8">3&nbsp;&nbsp;Çeviri</A>
<UL><LI>
<A HREF="#htoc9">3.1&nbsp;&nbsp;Kod Değişiklikleri</A>
<UL><LI>
<A HREF="#htoc10">3.1.1&nbsp;&nbsp;Temel Kullanım</A>
<LI><A HREF="#htoc11">3.1.2&nbsp;&nbsp;Sorunlu Noktalar</A>
<LI><A HREF="#htoc12">3.1.3&nbsp;&nbsp;İleri Kullanım</A>
</UL>
<LI><A HREF="#htoc13">3.2&nbsp;&nbsp;Derleme Sistemi Değişiklikleri</A>
<UL><LI>
<A HREF="#htoc14">3.2.1&nbsp;&nbsp;'po' Dizini</A>
<LI><A HREF="#htoc15">3.2.2&nbsp;&nbsp;'configure.in' Dosyası</A>
<LI><A HREF="#htoc16">3.2.3&nbsp;&nbsp;'Makefile.in' Dosyası</A>
<LI><A HREF="#htoc17">3.2.4&nbsp;&nbsp;Kod Dizinleri</A>
</UL>
<LI><A HREF="#htoc18">3.3&nbsp;&nbsp;Çeviri</A>
<UL><LI>
<A HREF="#htoc19">3.3.1&nbsp;&nbsp;Açıklama</A>
<LI><A HREF="#htoc20">3.3.2&nbsp;&nbsp;Başlık</A>
<LI><A HREF="#htoc21">3.3.3&nbsp;&nbsp;İletiler</A>
<LI><A HREF="#htoc22">3.3.4&nbsp;&nbsp;Özel durumlar</A>
</UL>
</UL>
<LI><A HREF="#htoc23">4&nbsp;&nbsp;Yazılımların Türkçe ile Sorunu Ne?</A>
<UL><LI>
<A HREF="#htoc24">4.1&nbsp;&nbsp;Sorun: toupper() ile karakter dönüşümü gerçekleşmiyor</A>
<LI><A HREF="#htoc25">4.2&nbsp;&nbsp;Sorun: Aynı bellek alanında dönüşüm bellek alanını bozuyor</A>
<LI><A HREF="#htoc26">4.3&nbsp;&nbsp;Sorun: Anahtar kelimelerin hatalı dönüşümü</A>
</UL>
</UL>


<!--TOC section Yerel Sistemi-->

<H2><A NAME="htoc1">1</A>&nbsp;&nbsp;Yerel Sistemi</H2><!--SEC END -->

Programların değişik ülke ve kültürlerin iletişim kurallarına uydurulabilmesi
için geliştirilmiştir. Bu kurallar, tarih ve saatin yazım şekli gibi
basitlerden, kullanılan dilin özellikleri gibi karmaşıklara kadar
yayılabilir. Programlar çalışma ortamından kullanıcının belirlediği
kural kümelerini alır ve kendilerini buna uydururlar. Bu kümelere
yerel (locale) adı verilir.<BR>
<BR>
<!--TOC subsection Kategoriler-->

<H3><A NAME="htoc2">1.1</A>&nbsp;&nbsp;Kategoriler</H3><!--SEC END -->

ISO C standardı aşağıdaki yerel kategorilerini tanımlar:
<DL COMPACT=compact><DT>
<B>LC_CTYPE</B><DD>Karakter kodlamaları. Karakter sınıflama (isalpha, isspace,
...), karakter dönüştürme (tolower, mbstowcs, ...), sözcük
karşılaştırma (strcmp, strcasecmp, ...) gibi fonksiyonların
davranışını belirler.
<DT><B>LC_COLLATE</B><DD>Yerel kurallarına göre sıralama (strcoll, strxfrm, ...)
fonksiyonlarının davranışını belirler.
<DT><B>LC_MESSAGES</B><DD>Program iletilerinin dilini belirler. 'gettext' seçili
olan dili burdan bulur.
<DT><B>LC_MONETARY</B><DD>Para değerlerinin gösterimi için kullanılan kuruş ve
binlik ayrım işareti, para birimi gibi bilgileri verir.
<DT><B>LC_NUMERIC</B><DD>Sayıların gösterim kurallarını verir. Biçimli G/Ç fonksiyonları
(printf, atof, ...) bu kuralları kullanır.
<DT><B>LC_TIME</B><DD>Tarih ve saat gösterim biçimi, ay ve günlerin adları gibi
bilgileri verir. strftime ve benzeri fonksiyonların davranışlarını
belirler.
<DT><B>LC_ALL</B><DD>Tüm kategorileri kapsar.
</DL>
Sözcüklerin karşılaştırılması, büyük/küçük harf dönüşümü, biçimli
G/Ç gibi standart C kitaplığınca sağlanan görevler, o anda geçerli
yerel seçimine göre otomatik olarak doğru sonuçları döndürürler. Yerel
kurallarına göre sıralama, iletilerin çevrilebilmesi gibi özellikler
için ise, programın bu özelliği destekleyecek biçimde yazılması gerekir.<BR>
<BR>
<!--TOC subsection Yerel İsimleri-->

<H3><A NAME="htoc3">1.2</A>&nbsp;&nbsp;Yerel İsimleri</H3><!--SEC END -->

Öntanımlı olarak her sistemde bulunan üç adet yerel adı vardır:
<DL COMPACT=compact><DT>
<B>``C''</B><DD>Fonksiyonlar ISO C tarafından standartlaştırıldığı biçimde
davranırlar. Programlar çalışmaya her zaman bu yerel ile başlar.
<DT><B>``POSIX''</B><DD>Posix standardını belirtir. C ile eş özellikler taşır.
<DT><B>``''</B><DD>Boş bir isim verildiğinde, ortam değişkenlerinden kullanıcının
ayarladığı yerel seçilir.
</DL>
Diğer yerel isimleri sistemden sisteme değişmektedir. Kabuk ortamında
<BLOCKQUOTE>
locale --a
</BLOCKQUOTE>
komutunu vererek kurulu yerelleri görebilirsiniz. Yerel isimleri genellikle
şu biçimdedir:
<BLOCKQUOTE>
dil [ _bölge ] [ .karakterseti ] [ @değiştirici ]
</BLOCKQUOTE>
Köşeli parantez içindeki kısımlar isteğe bağlıdır. Dil için ISO 639
tarafından tanımlanmış iki küçük harften oluşan dil kodları (en, tr,
fr, ...) kullanılır. Bölge ise ISO 3166 ile tanımlanan iki büyük
harfle (US, GB, TR, ...) gösterilir.<BR>
<BR>
<!--TOC subsection Yerel Seçimi-->

<H3><A NAME="htoc4">1.3</A>&nbsp;&nbsp;Yerel Seçimi</H3><!--SEC END -->

Program içinden yerel seçmek için
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
char&nbsp;*setlocale&nbsp;(int&nbsp;category,&nbsp;const&nbsp;char&nbsp;*locale);
</TT></DL></DIV>
çağrısı kullanılır. İlk parametre değiştirilecek kategoriyi belirten
ve yerel kategorileri ile aynı adı taşıyan makrolardan biridir. İkinci
parametre ise seçilecek yerel adıdır. Fonksiyon geçerli yerel adını
geriye döndürür. Dönen değer C kitaplığına ait olduğu için üzerinde
değişiklik yapmayın, yapmanız gerekiyorsa yada ilerde kullanacaksanız
bir kopyasını alın. Verdiğiniz yerele geçiş yapılamazsa geriye NULL
değeri döner. İkinci parametre olarak NULL değerini vererek, o anki
yerel adını bir değişikliğe yol açmadan öğrenebilirsiniz.<BR>
<BR>
Program başlangıcında kullanıcının ayarlarını geçerli kılmak için:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
setlocale&nbsp;(LC_ALL,&nbsp;"");
</TT></DL></DIV>
komutunu vermelisiniz. Bir işlem için standard yerele ihtiyacınız
olduğunda yada geçici olarak yerel değiştirmek istiyorsanız şöyle
bir kod kullanabilirsiniz:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#include&nbsp;&lt;locale.h&gt;<BR>
<BR>
char&nbsp;*old,&nbsp;*saved;<BR>
<BR>
old&nbsp;=&nbsp;setlocale&nbsp;(LC_ALL,&nbsp;NULL);<BR>
<BR>
if&nbsp;(old)&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;saved&nbsp;=&nbsp;strdup&nbsp;(old);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set_locale&nbsp;(LC_ALL,&nbsp;"C");<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set_locale&nbsp;(LC_ALL,&nbsp;saved);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;free&nbsp;(saved);<BR>
<BR>
}
</TT></DL></DIV>
<!--TOC section UNICODE-->

<H2><A NAME="htoc5">2</A>&nbsp;&nbsp;UNICODE</H2><!--SEC END -->

UNICODE, Unicode Consortium organizasyonu tarafından geliştirilen
ve her karaktere bir sayı değeri karşılığı atayan bir standarttır.
Evrensel Karakter Seti (UCS) olarak bilinen ISO/IEC 10646 standardı
ise, her iki organizasyonun işbirliği ile aynı sayısal karşılıkları
taşımaktadır. Bu set,
<UL><LI>
Yeryüzündeki tüm karakterlere bir sayı değeri atamayı amaçlamaktadır.
<LI>Zaman içinde yeni karakterler eklenebilir ama eski karakterlerin sayı
değerleri aynı kalır.
<LI>Sayı değerleri UCS-4 adlı 31 bitlik set üzerinden verilir. İlk 7 bit
'Group', sonraki 8 bit 'Plane', sonraki 8 bit 'Row', en son 8 bit
'Cell' olarak gruplanır. İlk 'Plane' (group = 0, plane = 0) Basic
Multilingual Plane (BMP) olarak adlandırılır. BMP, UCS-2 adı verilen
16 bitlik sete karşılık gelmektedir.
<LI>UCS üzerindeki karakter kod noktaları genellikle <B>u</B>+0a31 biçiminde
onaltılık sistemde sayılar olarak gösterilir.
<LI><B>u</B>+0021 -- <B>u</B>+007e arasındaki kodlar ASCII ile, <B>u</B>+00a0
-- <B>u</B>+00ff arasındaki kodlar ISO 8859-9 ile aynı tutulmuştur.
</UL>
Unicode kodlarından oluşan karakter dizilerini (metinleri) bilgisayarda
verimli bir biçimde saklayabilmek amacıyla çeşitli karakter kodlamaları
(encoding) geliştirilmiştir.<BR>
<BR>
<!--TOC subsection UTF-8 (RFC 3629)-->

<H3><A NAME="htoc6">2.1</A>&nbsp;&nbsp;UTF-8 (RFC 3629)</H3><!--SEC END -->

UTF-8 (Unicode Transformation Format - 8bit) kodlaması UNICODE karakterlerini
1-6 byte uzunluğunda diziler olarak kodlar. ASCII kodlaması içinde
0-127 arasında kalan karakterler aynen kendi kodları ile kullanılır,
diğerleri ise byte dizileri haline gelir.<BR>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP><TT><FONT SIZE=2>U+00000000 - U+0000007F</FONT></TT></TD>
<TD ALIGN=left NOWRAP><TT><FONT SIZE=2>0xxxxxxx</FONT></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT><FONT SIZE=2>U+00000080 - U+000007FF</FONT></TT></TD>
<TD ALIGN=left NOWRAP><TT><FONT SIZE=2>110xxxxx 10xxxxxx</FONT></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT><FONT SIZE=2>U+00000800 - U+0000FFFF</FONT></TT></TD>
<TD ALIGN=left NOWRAP><TT><FONT SIZE=2>1110xxxx 10xxxxxx 10xxxxxx</FONT></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT><FONT SIZE=2>U+00010000 - U+001FFFFF </FONT></TT></TD>
<TD ALIGN=left NOWRAP><TT><FONT SIZE=2>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</FONT></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT><FONT SIZE=2>U+00200000 - U+03FFFFFF</FONT></TT></TD>
<TD ALIGN=left NOWRAP><TT><FONT SIZE=2>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</FONT></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT><FONT SIZE=2>U+04000000 - U+7FFFFFFF</FONT></TT></TD>
<TD ALIGN=left NOWRAP><TT><FONT SIZE=2>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
10xxxxxx</FONT></TT></TD>
</TR></TABLE><BR>
UTF-8 şu özellikleri taşır:
<UL><LI>
Her saf (0-127 arası karakterlerden oluşan) ASCII dizisi geçerli bir
UTF-8 dizisidir.
<LI>0 ile 127 arası değerler kendi karakter karşılıkları dışında dizilerde
geçmezler. Böylece örneğin '%', ':', '(', ')' gibi karakterleri parse
edip, diğer karakterleri aynen geçiren parser ve programlar (ayrıca
C printf benzeri fonksiyonları) diğer UNICODE karakterlerinden etkilenmezler.
<LI>Sıfır değerli byte dizi içinde geçmez. Böylece strlen gibi fonksiyonlar
çalışmaya devam eder. Ancak gerçek karakter uzunluğu yerine byte uzunluğu
döndürmeye devam ettiklerine dikkat edilmelidir.
<LI>Bir UTF-8 byte'ı bir karakterin kod dizisinin ilk byte'ı ise, kendisinden
sonra kaç byte geleceği hemen anlaşılır. Herhangi bir byte'ın bir
karakter kodunun dizisine ait olduğu tek bir bit kontrolü ile anlaşılır.
<LI>Boyer-Moore hızlı metin arama algoritması UTF-8 ile kullanılabilir.
<LI>UTF-8 - Unicode çevrimleri kolaydır.
<LI>UTF-8 dizilerini başka bir karakter kodlaması bilgisi olmaması durumunda
istatistiksel olarak tesbit etmek kolaydır.
<LI>MIME kodlamalarında ve başka yerlerde 'UTF-8' biçiminde yazılır.
<LI>UTF-8 kullanan uygulamalar, güvenlik açısından her karakter dizisinin
geçerliliğini kontrol etmelidir. Her olası byte dizisi geçerli bir
UTF-8 dizisi değildir. Örnek olarak geçersiz UTF-8 dizisi 0xC0 0x80,
eğer normal UTF-8 çevrimi işlemine sokulursa sıfır karakter değerini
verir. Aynı şekilde 0x2F 0x2E 0x2E 0x2F (/../) yi yasaklayan bir program,
geçersiz 0x2F 0xC0 0xAE 0x2E 0x2F dizisi ile kandırılabilir. Bu sebepten
dışardan gelen her türlü UTF-8 dizisinin önce geçerliliği kontrol
edilmelidir.
</UL>
UTF-8 geriye uyumluluk sağlaması ve Türkçe için en az bellek israfına
yol açması nedeniyle Uludağ projesinde öntanımlı karakter kodlaması
olarak tercih edilmiştir.<BR>
<BR>
<!--TOC subsection UTF-16 (RFC 2781)-->

<H3><A NAME="htoc7">2.2</A>&nbsp;&nbsp;UTF-16 (RFC 2781)</H3><!--SEC END -->

UTF-16 (Unicode Transformation Format - 16bit), Unicode BMP içinde
kalan karakterleri 2 byte'lık diziler olarak kodlar. BMP dışında kalan
karakterleri kodlayabilmek için surrogate pair (vekil çift?) denen
4 byte'lık diziler kullanılır.<BR>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP><TT><FONT SIZE=2>U+00000000 - U+0000FFFF</FONT></TT></TD>
<TD ALIGN=left NOWRAP><TT><FONT SIZE=2>xxxxxxxx xxxxxxxx</FONT></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT><FONT SIZE=2>U+00010000 - U+0010FFFF</FONT></TT></TD>
<TD ALIGN=left NOWRAP><TT><FONT SIZE=2>110110xx xxxxxxxx 110111xx xxxxxxxx</FONT></TT></TD>
</TR></TABLE><BR>
Çiftin üst on bitini içeren kısmı 0xD800 ile 0xDBFF arasındayken,
alt on biti taşıyan kısım 0xDC00 ile 0xDFFF arasındadır. Bu değerler
arasındaki 16 bitlik değerler Unicode üzerinde özel olarak UTF-16'ya
ayrılmış ve hiç bir karaktere atanmamıştır.<BR>
<BR>
İşlemciler 16 bitlik değerleri bellekte tutmak için farklı yöntemler
kullanmaktadır. Örneğin 258 (0x0102) değeri little-endian işlemcilerde
0x02 0x01, big-endian işlemcilerde ise 0x01 0x02 diziliminde tutulmaktadır.<BR>
<BR>
UTF-16 dizileri için bir endian standardı belirlenmemiştir. Metin
UTF-16BE ya da UTF-16LE olarak işaretlenmemişse (MIME, vb ile) işleyici
metnin ilk iki byte'ına bakar. Byte sıra işareti (Byte Order Mark,
BOM) adlı karakter (0xFEFF) metnin byte sıralanmasını göstermek için
ayrılmıştır. İlk iki byte 0xFF 0xFE ise metin little-endian, 0xFE
0xFF ise big-endian olarak işlenir. UTF-16 metinleri birbirine eklerken
araya gelen BOM karakterini çıkartmaya dikkat edilmelidir. İşaretlenmemiş
ve BOM taşımayan diziler için bir yol gösterilmemiştir.<BR>
<BR>
<!--TOC section Çeviri-->

<H2><A NAME="htoc8">3</A>&nbsp;&nbsp;Çeviri</H2><!--SEC END -->

Uygulamaların içerdiği iletilerin diğer dillere kolayca çevrilebilmesini
sağlamak için ``gettext'' adında bir alt yapı geliştirilmiştir.
Programların nasıl yazılması gerektiğine dair bir dizi kural, çeviri
dosyaları için bir biçim, çevrilmiş iletilere erişmek için bir kitaplık
ve çevirileri işlemek için çeşitli araçlardan oluşmaktadır. Uygulamaların
en az değişiklikle çevrilebilir hale getirilebilmeleri için tasarlanmıştır
ve çok yaygın olarak kullanılmaktadır.<BR>
<BR>
Bir uygulamanın çevrilebilmesi için, kod ve derleme sistemi üzerinde
gerekli değişiklikler programcı tarafından yapılmış olmalıdır. Bundan
sonra çevirmen uygulamaya ait 'po' dosyalarını çevirerek uygulamayı
yerelleştirebilir.<BR>
<BR>
<!--TOC subsection Kod Değişiklikleri-->

<H3><A NAME="htoc9">3.1</A>&nbsp;&nbsp;Kod Değişiklikleri</H3><!--SEC END -->

<!--TOC subsubsection Temel Kullanım-->

<H4><A NAME="htoc10">3.1.1</A>&nbsp;&nbsp;Temel Kullanım</H4><!--SEC END -->

'gettext' programlama arabirimi, Sun tarafından 1990 yılında Uniforum'a
gönderilen bir öneriden yola çıkmıştır. Bugün için OpenI18N standardı
tarafından belirlenir. Temel özelliği programların en az değişiklikle
çevrilebilir hale getirilebilmesidir.<BR>
<BR>
Burdaki çağrıları kullanabilmek için öncelikle 'libintl.h' adlı başlık
dosyası include edilir. Bunu gettext çağrılarının kullanıldığı kod
dosyalarında ve gettext ile çevrilen format string'lerini kullanan
printf, sprintf, vb fonksiyonlarının bulunduğu dosyalarda yapmalısınız.<BR>
<BR>
Çeviri sistemin en temel işlevleri; çevrilecek iletilerin bulunduğu
alanı belirlemek, ve iletiye karşılık gelen çeviriyi almaktır. Tüm
programların iletilerinin aynı alanda tutulması, bakım ve yönetim
açısından zor olacağı için bu alan kavramı kullanılır. Çeviri alanı,
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
char&nbsp;*textdomain&nbsp;(const&nbsp;char&nbsp;*domain_name);&nbsp;
</TT></DL></DIV>
fonksiyonu ile belirlenir. domain_name seçilecek alan adını içeren
bir C string'idir. NULL değerini taşıması durumunda seçimi değiştirmeden
o an aktif olan alan adını öğrenebilirsiniz. Alanın dosya sisteminde
hangi dizinden çevirilere bakacağını;
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
char&nbsp;*bindtextdomain&nbsp;(const&nbsp;char&nbsp;*domain_name,<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*dir_name);&nbsp;
</TT></DL></DIV>
ile belirleyebilirsiniz. Bu işlemler genellikle programın başında
yapılır. Bir örnek:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
setlocale&nbsp;(LC_ALL,&nbsp;NULL);&nbsp;<BR>
bindtextdomain&nbsp;(PACKAGE,&nbsp;LOCALEDIR);&nbsp;<BR>
textdomain&nbsp;(PACKAGE);
</TT></DL></DIV>
Burada ilk önce, setlocale çağrısı ile standart C kitaplığının tüm
kategorilerde kullanıcının seçtiği yerelleştirmeyi kullanması sağlanmakta.
Daha sonra ise alana ait dizin seçilmekte ve alan etkinleştirilmektedir.
PACKAGE ve LOCALEDIR makroları, autoconf sistemi tarafından "ornek"
ve "/usr/share/locale" olarak ayarlanmıştır. Bu
durumda bu satırlar çalıştığında Türkçe için /usr/share/locale/tr/LC_MESSAGES/ornek.mo"
adlı dosyadan çeviriler yüklenecek ve kullanıma hazır hale gelecektir.<BR>
<BR>
Bu alandan bir ileti çevirisi almak için ise,
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
char&nbsp;*gettext&nbsp;(const&nbsp;char&nbsp;*msgid);&nbsp;
</TT></DL></DIV>
fonksiyonu kullanılır. Dönüş değeri, verilen iletinin, o an seçili
alan içinde, kullanıcının ayarladığı dile çevrilmiş halidir. Bu çağrıyı
alanı değiştirip tekrar yaparsanız, ikinci sonuç yeni seçilen alandan
gelir. Optimizasyon açısından döngü içinde kullanmamakta yarar görülebilirse
de, GNU gettext alan değişmediği sürece çeviri sonuçlarını cache'lediğinden
bu o kadar önemli değildir. Kullanıcının dilinde bir çeviri olmadığı
durumlarda gettext, msgid iletisini aynen geri verir.
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
printf&nbsp;(gettext&nbsp;("Hello&nbsp;dear&nbsp;translator,&nbsp;6&nbsp;*&nbsp;9&nbsp;=&nbsp;%d"),&nbsp;42);&nbsp;
</TT></DL></DIV>
Örnekte görüldüğü gibi kullanılan yazı dizilerini gettext fonksiyonu
içine almak gibi çok kolay bir işlem ile program çevrilebilir hale
gelmekte. Çevrilecek iletiler başka bazı sistemlerdeki gibi özel ID
ler ile belirtilmek yerine direk kendi metni ile aranmakta. Tabi bunu
daha da kolaylaştırmak için C dilinin makro özelliğinden yararlanabiliriz:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#define&nbsp;_(Dizi)&nbsp;gettext&nbsp;(Dizi)&nbsp;<BR>
printf&nbsp;(_("Hello&nbsp;dear&nbsp;translator,&nbsp;6&nbsp;*&nbsp;9&nbsp;=&nbsp;%d"),&nbsp;42);
</TT></DL></DIV>
Böylece her ileti başına yalnızca 3 karakter (altçizgi, parantez aç,
parantez kapa) israf etmiş oluyoruz. Program yazmaya başlarken bir
i18n.h başlık dosyası yaratıp içine bu makroyu
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#define&nbsp;_(Dizi)&nbsp;Dizi&nbsp;
</TT></DL></DIV>
biçiminde koyarsanız ve iletilerinizi _(...) ile kuşatırsanız, ilerde
programın çevrilmesi gerektiğinde tek yapmanız gereken bu i18n.h dosyasını
değiştirip, programınızı gettext kitaplığı ile bağlamak olacaktır.
Yeni programlarınıza başlarken çeviri alt yapısını bütünüyle eklemeseniz
bile, bu basit işi yapıp, ilerde kolaylık sağlamanızı şiddetle öneriyoruz!<BR>
<BR>
Programınızda bu değişiklikleri yaptıktan sonra çağıracağınız xgettext
adlı program, tüm kodu tarayıp gettext ve _ ile işaretlenmiş metinleri
PROGRAMADI.pot adlı bir dosyada toplar. Daha sonra çevirmenler bu
özel biçimli dosyadan birer kopya çıkarıp içindeki metinleri çevirerek
programınızı kolayca başka bir dile taşıyabilir.<BR>
<BR>
<!--TOC subsubsection Sorunlu Noktalar-->

<H4><A NAME="htoc11">3.1.2</A>&nbsp;&nbsp;Sorunlu Noktalar</H4><!--SEC END -->

Tabi metinler program içinde her zaman böyle bir fonksiyon çağrısı
ile kolayca çevrilebilecek biçimde kullanılmıyor. Dillerin farklı
yapıları da kimi sorunlar çıkarmakta. Örneğin isimlerin çoğul ve tekil
hallerinin kullanımı dilden dile değişmekte.
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
printf&nbsp;("%d&nbsp;file%s&nbsp;deleted",&nbsp;n,&nbsp;n&nbsp;==&nbsp;1&nbsp;?&nbsp;""&nbsp;:&nbsp;"s");&nbsp;
</TT></DL></DIV>
Burada son parametredeki ? deyimi n değeri 1 olmadığı koşullarda 'file'
yerine 'files' şeklinde çıktı verilmesini sağlamakta. Ancak Türkçe
ve benzeri dillerde İngilizce'deki bu kural yok. Bu durumlarda daha
açık yazmayı tercih etmelisiniz:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
if&nbsp;(n&nbsp;==&nbsp;1)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;("%d&nbsp;file&nbsp;deleted",&nbsp;n);&nbsp;<BR>
else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;("%d&nbsp;files&nbsp;deleted",&nbsp;n);&nbsp;
</TT></DL></DIV>
Her zaman iletileri gettext ile kuşatmanız mümkün olmayabilir. Örneğin:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
static&nbsp;const&nbsp;char&nbsp;*messages[]&nbsp;=&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;"some&nbsp;very&nbsp;meaningful&nbsp;message",<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;"and&nbsp;another&nbsp;one"<BR>
<BR>
};&nbsp;<BR>
fputs&nbsp;(gettext&nbsp;(messages[i]));
</TT></DL></DIV>
Burdaki sorun, basılacak olan ileti için gettext fonksiyonunun çağrılması,
ancak çevrilecek iletileri içeren dosyayı oluşturacak xgettext programının
kod içerisinde bu iletileri görememesidir. Bunu çözümü için;
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#define&nbsp;gettext_noop(x)&nbsp;x&nbsp;<BR>
static&nbsp;const&nbsp;char&nbsp;*messages[]&nbsp;=&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gettext_noop&nbsp;("some&nbsp;very&nbsp;meaningful&nbsp;message"),&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gettext_noop&nbsp;("and&nbsp;another&nbsp;one")&nbsp;<BR>
};&nbsp;<BR>
fputs&nbsp;(gettext&nbsp;(messages[i]));
</TT></DL></DIV>
kullanılabilir. gettext_noop için N_ makrosu da tanımlanabilir,
böylece fazla yazı yazmaktan kurtulunur.
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#define&nbsp;N_&nbsp;(x)&nbsp;gettext_noop&nbsp;(x)&nbsp;
</TT></DL></DIV>
Bu iki makro da herhangi bir kod çağırmaz, yalnızca metinlerin çevrilecek
metinler olduğunu xgettext'in anlamasını sağlarlar.<BR>
<BR>
Çevirilerin rahatça yapılabilmesi için, özgün iletilerinizin belirsizlik
içermeyen, anlaşılır, tam tümceler olmasına dikkat edin. Sözcükleri
birleştirmek yerine birden fazla tümce kullanmayı tercih edin, örneğin:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
printf&nbsp;("File&nbsp;%s&nbsp;is&nbsp;%s",&nbsp;filename,<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;&lt;&nbsp;16000&nbsp;?&nbsp;"small"&nbsp;:&nbsp;"big");&nbsp;
</TT></DL></DIV>
yerine:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
printf&nbsp;(size&nbsp;&lt;&nbsp;16000&nbsp;?&nbsp;_("File&nbsp;%s&nbsp;is&nbsp;small")<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;_("File&nbsp;%s&nbsp;is&nbsp;big"),&nbsp;filename);&nbsp;
</TT></DL></DIV>
Tek bir durumu anlatan çok satırlı iletileri, satır satır basmak yerine,
içinde n ile satır dönüşü içeren tek bir ileti olarak
kullanmaya çalışın. Böylece çevirmenler yarım satırları çevirme ve
bölünme yüzünden tutarsız çevirmeler yapma durumunda kalmayacaklardır.<BR>
<BR>
<!--TOC subsubsection İleri Kullanım-->

<H4><A NAME="htoc12">3.1.3</A>&nbsp;&nbsp;İleri Kullanım</H4><!--SEC END -->

Tek bir çeviri alanı birçok program için yeterli olsa da, bunun yetersiz
kaldığı bazı durumlar var. Örneğin bir dizi program aynı hata mesajlarını
kullanıyorlarsa bunlar tek bir alanda toplanabilir, böylece bir kere
çevrilmeleri yeterli olur. Kitaplıklarda ise fonksiyonların çağıran
programın alanından bağımsız, kendi alanlarından çeviri almaları gereklidir.
Her ne kadar bu sorun textdomain () çağrıları ile çözülebilirse de,
yavaş ve kullanışsız olur. Bu amaç için:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
char&nbsp;*dgettext&nbsp;(const&nbsp;char&nbsp;*domain_name,&nbsp;const&nbsp;char&nbsp;*msgid);&nbsp;
</TT></DL></DIV>
fonksiyonu yardımcı olur. Bununla farklı alanlardan ileti çevirileri
alabilirsiniz.<BR>
<BR>
gettext sistemi yalnızca ileti çevirilerini getirmekle kalmaz, aynı
zamanda bunları saklandıkları karakter setinden, o anki yerelleştirmenin
LC_CTYPE ile belirlenen etkin karakter setine de çevirir. Metinleri
yerelleştirmeye bağlı kalmadan kullanabilen programlar, çevirileri
UTF-8 karakter setinde isteyebilir. Bunun için,
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
char&nbsp;*bind_textdomain_charset&nbsp;(const&nbsp;char&nbsp;*domain_name,<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*codeset);&nbsp;
</TT></DL></DIV>
kullanılır. Örneğin:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
bind_textdomain_charset&nbsp;(PACKAGE,&nbsp;"UTF-8");&nbsp;
</TT></DL></DIV>
gettext çeviri bulamadığı durumda verilen iletiyi aynen döndürdüğü
için, bunun kullanıldığı durumlarda program kodundaki metinlerin UTF-8
olarak tutulması gerektiğine dikkat edin! <BR>
<BR>
<!--TOC subsection Derleme Sistemi Değişiklikleri-->

<H3><A NAME="htoc13">3.2</A>&nbsp;&nbsp;Derleme Sistemi Değişiklikleri</H3><!--SEC END -->

Kimi uygulamalar arşiv dosyasından açıldıklarında tek bir dizin içinde
yayılır. Kimi uygulamaların ise kendi dizin hiyerarşisi mevcuttur.
gettext kodu ve gereksindiği dosyalar çok sayıda ve karmaşık olduğu
için, en azından onları uygun bir biçimde ayrı dizinler olarak koymanız
tavsiye edilir. Uygulama GNU autoconf sistemini kullanıyorsa gettext
entegrasyonu çok kolay olacağı için öncelikle uygulamayı autoconf
standardına taşımayı düşünün.<BR>
<BR>
Çerçeveyi otomatik olarak kurmak için ``gexttextize'' adlı uygulama
kullanılır. Uygulamanın en üst dizininde
<BLOCKQUOTE>
gettextize --intl
</BLOCKQUOTE>
komutunu verdiğinizde aşağıdaki işlemleri yapar:
<OL type=1><LI>
Yerelleştirmenin kullanımı ile ilgili bilgiler veren bir ABOUT-NLS
dosyası en üst dizine kopyalanır.
<LI>Çevirileri tutacak bi 'po' dizini yaratılır.
<LI>gettext kodlarını tutacak bir 'intl' dizini yaratılır. Burdaki dosyalar
kopyalanmak yerine sistemden sembolik link yapılır. Bu diskte az yer
kullanarak tasarruf etmeyi ve dosyaların sistemde kurulu sürümleri
ile güncel kalmasını sağlar. Uygulamayı arşivlerken tar'ın -h seçeneğini
kullanarak dosyaların asıllarının arşivlenmesini sağlamalısınız. gettextize'nin
--copy seçeneğini kullanarak dosyaların link edilmek
yerine kopyalanmasını sağlayabilirsiniz. Bu yolu seçerseniz arada
bir gettextize komutunu çağırarak dosyaların yeni sürümlerini uygulamanıza
dahil etmeyi unutmayın.
<LI>Autoconf için config.rpath ve mkinstalldirs dosyaları 'configure'
destek dosyalarının olduğu dizine kopyalanır. Automake de kullanıyorsanız,
gereken makro dosyaları 'm4' dizinine kopyalanır.
</OL>
Bu işlemden sonra bazı dosyalarda ufak değişikler yaparak entegrasyon
tamamlanır:<BR>
<BR>
<!--TOC subsubsection 'po' Dizini-->

<H4><A NAME="htoc14">3.2.1</A>&nbsp;&nbsp;'po' Dizini</H4><!--SEC END -->

Burda öncelikle POTFILES.in adlı bir dosya açıp içine çevrilecek iletileri
içeren kod dosyalarının uygulamanın en üst dizinine göre göreceli
yolunu yazmalısınız. Örnek bir dosya:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#&nbsp;List&nbsp;of&nbsp;source&nbsp;files&nbsp;containing&nbsp;translatable&nbsp;strings<BR>
<BR>
lib/error.c<BR>
<BR>
lib/getopt.c<BR>
<BR>
src/main.c<BR>
<BR>
src/ui.c
</TT></DL></DIV>
Bir sonraki adım LINGUAS adlı bir dosyaya hangi çevirilerin mevcut
olduğunu boşluklarla ayrılmış biçimde yazmak. Kullanıcılar hangi dilleri
istediklerini burayı değiştirmek yerine LINGUAS adlı ortam değişkenini
değiştirerek ayarlayabilir. Almanca, Fransızca ve Türkçe çeviriler
içeren bir uygulama için bir örnek:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#&nbsp;Available&nbsp;languages<BR>
<BR>
de&nbsp;fr&nbsp;tr
</TT></DL></DIV>
Tabiki çeviri dosyalarını da de.po, fr.po, tr.po olarak buraya koymalısınız.<BR>
<BR>
<!--TOC subsubsection 'configure.in' Dosyası-->

<H4><A NAME="htoc15">3.2.2</A>&nbsp;&nbsp;'configure.in' Dosyası</H4><!--SEC END -->

Bu dosya autoconf tarafından işlenip 'configure' scriptini yaratmakta
kullanılmaktadır. Yeni uygulamalarda 'configure.ac' adını da taşıyabilir.
gettext'in işleyebilmesi için burada şu işlemler yapılmalıdır:
<OL type=1><LI>
PACKAGE ve VERSION değerlerini tanımlamalısınız. Eğer automake kullanıyorsanız
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
AM_INIT_AUTOMAKE(myapp,1.0.5)
</TT></DL></DIV>
<LI>Uluslararasılaşma desteğini kontrol etmelisiniz.
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
AM_GNU_GETTEXT
</TT></DL></DIV>
<LI>Değişiklerin yazılacağı dosyaları belirtmelisiniz.
<OL type=a><LI>
Eski autoconf modeli için:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
AC_OUTPUT([&nbsp;...sizin&nbsp;dosyalarınız...<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intl/Makefile&nbsp;po/Makefile.in])
</TT></DL></DIV>
<LI>Yeni autoconf için:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
AC_CONFIG_FILES([&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...sizin&nbsp;dosyalarınız...&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intl/Makefile&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;po/Makefile.in&nbsp;<BR>
])
</TT></DL></DIV>
</OL>
</OL>
<!--TOC subsubsection 'Makefile.in' Dosyası-->

<H4><A NAME="htoc16">3.2.3</A>&nbsp;&nbsp;'Makefile.in' Dosyası</H4><!--SEC END -->

Derleme sırasında intl ve po dizinlerinizin de işlenmesini sağlamalısınız.
Eğer automake kullanıyorsanız 'Makefile.am' dosyasında
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
SUBDIRS&nbsp;=&nbsp;intl&nbsp;...sizin&nbsp;dizinleriniz...&nbsp;po
</TT></DL></DIV>
şeklinde bir değişiklik yeterli olacaktır.<BR>
<BR>
<!--TOC subsubsection Kod Dizinleri-->

<H4><A NAME="htoc17">3.2.4</A>&nbsp;&nbsp;Kod Dizinleri</H4><!--SEC END -->

Program girişinde çeviri alanınızı ayarlarken kullanacağınız LOCALEDIR
makrosunu kod dizininiz içinde 'Makefile.in' yada automake kullanıyorsanız
'Makefile.am' dosyasında şöyle tanımlayabilirsiniz:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
datadir&nbsp;=&nbsp;@datadir@<BR>
<BR>
localedir&nbsp;=&nbsp;$(datadir)/locale<BR>
<BR>
DEFS&nbsp;=&nbsp;-DLOCALEDIR=''$(localedir)''&nbsp;@DEFS@
</TT></DL></DIV>
Programlar derlendikten sonra @LIBINTL@ (yada libtool kullanıyorsanız
@LTLIBINTL@) ile bağlandıklarından emin olun. Bunu şöyle yapabilirsiniz:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
LIBS&nbsp;=&nbsp;...sizin&nbsp;kitaplıklarınız...&nbsp;@LIBINTL@
</TT></DL></DIV>
Derleyicinizin 'intl' dizinindeki C başlık dosyalarına erişebilmesi
için, derleme hedeflerinizde
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
-I$(top_srcdir)/intl
</TT></DL></DIV>
parametresinin derleyiciye verilmesini sağlayın.<BR>
<BR>
<!--TOC subsection Çeviri-->

<H3><A NAME="htoc18">3.3</A>&nbsp;&nbsp;Çeviri</H3><!--SEC END -->

Çeviriye başlarken ilk önce, paketadı.pot adlı şablon dosyasından
DİL.po (Türkçe için tr.po) adında bir kopya çıkartılır. Daha sonra
bu dosyanın açıklamaları ve başlık bilgileri düzenlenir, ve iletiler
teker teker çevrilir.<BR>
<BR>
<!--TOC subsubsection Açıklama-->

<H4><A NAME="htoc19">3.3.1</A>&nbsp;&nbsp;Açıklama</H4><!--SEC END -->

Örnek bir .pot dosyasının giriş kısmı:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#&nbsp;SOME&nbsp;DESCRIPTIVE&nbsp;TITLE.<BR>
<BR>
#&nbsp;This&nbsp;file&nbsp;is&nbsp;distributed&nbsp;under&nbsp;the&nbsp;same&nbsp;license&nbsp;as&nbsp;the&nbsp;PACKAGE&nbsp;package.<BR>
<BR>
#&nbsp;FIRST&nbsp;AUTHOR&nbsp;&lt;EMAIL@ADDRESS&gt;,&nbsp;YEAR.
</TT></DL></DIV>
Bu kısımda basitçe dosyanın ne olduğunu, paketle aynı lisansa sahip
olduğunu, ve çeviren kişi yada kişilerin isim ve elektronik mektup
adreslerini bildiriyoruz. Bir örnek:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#&nbsp;Turkish&nbsp;translation&nbsp;of&nbsp;Imposter<BR>
<BR>
#&nbsp;This&nbsp;file&nbsp;is&nbsp;distributed&nbsp;under&nbsp;the&nbsp;same&nbsp;license&nbsp;as&nbsp;the&nbsp;Imposter&nbsp;package.<BR>
<BR>
#&nbsp;Gurer&nbsp;Ozen&nbsp;&lt;email@adres.com&gt;,&nbsp;2003.
</TT></DL></DIV>
<!--TOC subsubsection Başlık-->

<H4><A NAME="htoc20">3.3.2</A>&nbsp;&nbsp;Başlık</H4><!--SEC END -->

Örnek bir .pot dosyasının başlık kısmı:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#,&nbsp;fuzzy<BR>
<BR>
msgid&nbsp;""<BR>
<BR>
msgstr&nbsp;""<BR>
<BR>
"Project-Id-Version:&nbsp;PACKAGE&nbsp;VERSIONn"<BR>
<BR>
"Report-Msgid-Bugs-To:&nbsp;imposter-devel@lists.sourceforge.netn"<BR>
<BR>
"POT-Creation-Date:&nbsp;2004-05-30&nbsp;23:50+0300n"<BR>
<BR>
"PO-Revision-Date:&nbsp;YEAR-MO-DA&nbsp;[HO]MI+ZONEn"<BR>
<BR>
"Last-Translator:&nbsp;FULL&nbsp;NAME&nbsp;&lt;EMAIL@ADDRESS&gt;n"<BR>
<BR>
"Language-Team:&nbsp;LANGUAGE&nbsp;&lt;LL@li.org&gt;n"<BR>
<BR>
"MIME-Version:&nbsp;1.0n"<BR>
<BR>
"Content-Type:&nbsp;text/plain;&nbsp;charset=UTF-8n"<BR>
<BR>
"Content-Transfer-Encoding:&nbsp;8bitn"
</TT></DL></DIV>
Görüldüğü gibi burda çeviri ile ilgili daha detaylı bilgiler var.
Açıklamalar dosyayı okuyan kişiye hitap ederken, bu kısım çeviri sistemi
tarafından kullanılıyor. Örneğin kullanılan karakter seti burda belirleniyor.
Burada PACKAGE ve VERSION yerine paket adı ve versiyonunu, PO-Revision-Date
kısmında çeviriyi en son düzenlediğiniz tarihi (Yıl-Ay-Gün Saat:Dakika),
Last-Translator'a adınız ve emailinizi, Language-Team'e ise çeviri
grubunun bilgisini girmek yeterli. İstediğimiz karakter setini (mesela
ISO-8859-9) kullanabilmekle birlikte (gettext programa bunları o anki
geçerli karakter setine çevirip verecektir), sistemde genel olarak
UTF-8 kullanacağımız için UTF-8 kullanmakta yarar var. Daha sonra
anlatacağımız "fuzzy" bayrağını kaldırmalısınız.<BR>
<BR>
Örnek bir tr.po dosyası başlığı:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#<BR>
<BR>
msgid&nbsp;""<BR>
<BR>
msgstr&nbsp;""<BR>
<BR>
"Project-Id-Version:&nbsp;imposter&nbsp;0.1n"<BR>
<BR>
"Report-Msgid-Bugs-To:&nbsp;imposter-dev@lists.sourceforge.netn"<BR>
<BR>
"POT-Creation-Date:&nbsp;2004-05-30&nbsp;23:50+0300n"<BR>
<BR>
"PO-Revision-Date:&nbsp;2003-07-03&nbsp;18:50+0300n"<BR>
<BR>
"Last-Translator:&nbsp;Gurer&nbsp;Ozen&nbsp;&lt;email@adres.com&gt;n"<BR>
<BR>
"Language-Team:&nbsp;tr&nbsp;&lt;tr@li.org&gt;n"<BR>
<BR>
"MIME-Version:&nbsp;1.0n"<BR>
<BR>
"Content-Type:&nbsp;text/plain;&nbsp;charset=UTF-8n"<BR>
<BR>
"Content-Transfer-Encoding:&nbsp;8bitn"
</TT></DL></DIV>
<!--TOC subsubsection İletiler-->

<H4><A NAME="htoc21">3.3.3</A>&nbsp;&nbsp;İletiler</H4><!--SEC END -->

.pot dosyasından örnek bir ileti:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#:&nbsp;src/ui.c:84<BR>
<BR>
msgid&nbsp;"Select&nbsp;a&nbsp;presentation&nbsp;file..."<BR>
<BR>
msgstr&nbsp;""
</TT></DL></DIV>
Çit işareti ile başlayan açıklama satırında çevrilecek iletinin kod
içinde hangi dosyanın hangi satırından alındığı belirtilmekte. msgid
çevrilecek iletiyi taşımakta. msgstr yi ise şimdi biz dolduracağız.
İletinin tr.po içindeki çevrilmiş hali:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#:&nbsp;src/ui.c:84<BR>
<BR>
msgid&nbsp;"Select&nbsp;a&nbsp;presentation&nbsp;file..."<BR>
<BR>
msgstr&nbsp;"Bir&nbsp;sunum&nbsp;dosyası&nbsp;seçin..."
</TT></DL></DIV>
olacak. Bu şekilde bütün iletiler çevrildiğinde işimiz tamamlanmakta.<BR>
<BR>
<!--TOC subsubsection Özel durumlar-->

<H4><A NAME="htoc22">3.3.4</A>&nbsp;&nbsp;Özel durumlar</H4><!--SEC END -->

Programların yeni sürümleriyle birlikte içerdikleri iletiler de değişmektedir.
Bazı yeni iletiler eklenirken, bazıları değişmekte, bazıları ise çıkarılmaktadır.
gettext sistemi .po dosyalarını güncellerken yeni eklenen iletilerin
çevirilerini boş bırakmaktadır, bunlar çevirmen tarafından doldurulur.<BR>
<BR>
Çıkarılan iletiler,
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#&nbsp;msgid&nbsp;"/File/_Close"<BR>
<BR>
#&nbsp;msgstr&nbsp;"/Dosya/Kapa_t"
</TT></DL></DIV>
biçimine gelir. Bunları dosyadan çıkarabilirsiniz.<BR>
<BR>
Değişen iletiler ya da gettext sisteminin düzgün çevrildiğine karar
veremediği iletiler ise fuzzy olarak işaretlenir:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#:&nbsp;src/main.c:70<BR>
<BR>
#,&nbsp;fuzzy<BR>
<BR>
msgid&nbsp;"I&nbsp;don't&nbsp;have&nbsp;eny&nbsp;easter&nbsp;eggs...&nbsp;or&nbsp;do&nbsp;I?"<BR>
<BR>
msgstr&nbsp;"Hiç&nbsp;sürprizim&nbsp;yok...&nbsp;yoksa&nbsp;var&nbsp;m??"
</TT></DL></DIV>
Burda özgün iletideki 'any' kelimesi 'eny' olarak değiştirildiğinde,
gettext .po dosyalarında sorun olabileceğini belirtmek için iletinin
çevirisini
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#,&nbsp;fuzzy
</TT></DL></DIV>
satırı ile işaretlemiş. Bu durumda çevirmen çeviriyi kontrol eder.
Gerekirse düzeltip fuzzy bayrağını kaldırır.<BR>
<BR>
C programlarında karşılaşılabilecek bir başka özel çeviri durumu ise
format stringleridir. Bunlar C tarafından basılacak çıktıyı şekle
sokmak için kullanılır. Bir örnek:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#:&nbsp;src/file.c:167<BR>
<BR>
#,&nbsp;c-format<BR>
<BR>
msgid&nbsp;"cannot&nbsp;open&nbsp;file&nbsp;%s"<BR>
<BR>
msgstr&nbsp;"%s&nbsp;dosyası&nbsp;açılamadı"
</TT></DL></DIV>
Burdaki c-format bayrağı, gettext sistemi tarafından otomatik olarak
konur ve iletinin bir format stringi olduğunu söyler. İletinin format
stringine benzemesi ama olmaması durumunda no-c-format bayrağı ile
de karşılaşabilirsiniz. Format stringleri içindeki %s %d gibi %
ile başlayan deyimler iletinin içind o yere başka bir değerin konacağını
gösterir. Örnekte programın basacağı ileti örneğin "cannot
open file resim.jpg" ya da Türkçe etkin iken "resim.jpg
dosyası açılamadı" olacaktır.<BR>
<BR>
Bu iletilerde % ifadelerini (%s: metin, %d: tamsayı, %f: sayı,
%c: karakter, vs) korumalısınız. Aksi durumda program hatalı çalışacak
ya da çakılacaktır. Dil yapısından dolayı yerlerini değiştirmeniz
gereken durumlarda aşağıdaki gibi kullanın:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
#:&nbsp;src/data.c:1203<BR>
<BR>
#,&nbsp;c-format<BR>
<BR>
msgid&nbsp;"%d&nbsp;of&nbsp;%d&nbsp;files&nbsp;processed"<BR>
<BR>
msgstr&nbsp;"%2$d&nbsp;dosyadan&nbsp;%1$d&nbsp;adet&nbsp;dosya&nbsp;işlendi"
</TT></DL></DIV>
Burada özgün iletide ikinci sırada olan toplam dosya adedini başa
almak için '%' ile 'd' (ya da hangi tür değer basılıyorsa onun harfi)
arasına SIRANO ve '$' koyarak iletiyi programı bozmadan değiştirmiş
olduk. <BR>
<BR>
<!--TOC section Yazılımların Türkçe ile Sorunu Ne?-->

<H2><A NAME="htoc23">4</A>&nbsp;&nbsp;Yazılımların Türkçe ile Sorunu Ne?</H2><!--SEC END -->

Pek çok yazılım Türkçe yerelleri (tr_TR ve tr_TR.UTF-8) ile kullanıldığında
istenilmeyen sonuçlar veriyor veya hiç çalışmıyorlar. Gözlemlenen
Türkçe sorunları büyük/küçük harf çevrimleri sırasında ortaya çıkıyor.
Sorunun asıl kaynağı ise İngilizce'deki i,I karakterlerinin Türkçede
farklı karşılıklarının olması.<BR>
<BR>
İngilizce'de i karakterinin büyük harf karşılığı I olarak ifade ediliyor.
Noktalı (küçük) ve noktasız (büyük) olmak üzere yalnızca iki i,I karakteri
bulunuyor.<BR>
<BR>
Türkçe'de ise i,İ,ı ve I karakterleri noktalılar ve noktasızlar olmak
üzere dört farklı karakter bulunuyor. Sorunun kaynağı olarak, İngilizce'deki
i-I dönüşümü Türkçe'de i-İ
ve ı-I olmak üzere farklı dönüşümler ile
ifade ediliyor.<BR>
<BR>
Herhangi bir yazılım i karakterini büyük harfe veya I karakterini
küçük harfe çevirmek istediği zaman üç farklı sorundan biri ortaya
çıkıyor.
<OL type=1><LI>
Dönüşüm gerçekleşmiyor ve karakter eski hali ile yazdırılıyor. Yazılım
dönüşümü yalnızca integer türü değerlerle çalışabilen toupper() fonksiyonu
ile yapmaya çalışıyor ve dönüşüm gerçekleşmiyor.
<LI>Yazılım tek bayt ile ifade edilen İngilizce i,I karakterlerini çok
baytlı İ,ı karakterlerine <B>aynı bellek alanında</B> dönüştürerek
bellek alanını (dolayısı ile girdi metinini) bozuyor.
<LI>Yazılım anahtar kelimesini Türkçe yereli için doğru bir şekilde gerçekleştiriyor,
fakat İngilizce dönüşümü göz önüne alınması gereken anahtar kelime
bozulmuş oluyor.
</OL>
Yukarıdaki sorun tipleri için farklı çözüm yöntemleri izlenmesi gerekiyor.<BR>
<BR>
<!--TOC subsection Sorun: toupper() ile karakter dönüşümü gerçekleşmiyor-->

<H3><A NAME="htoc24">4.1</A>&nbsp;&nbsp;Sorun: toupper() ile karakter dönüşümü gerçekleşmiyor</H3><!--SEC END -->

Bu sorun tr_TR.UTF-8 yerelinde ortaya çıkıyor. Eğer toupper çağısı
yapılıyorsa dönüş değerinin mutlaka kontrol edilmesi ve eğer dönüş
değeri 128bit'den büyük ise dönüşümün geniş karakterler ile çalışabilen
towupper() ile yapılması gerekiyor. towupper() fonksiyonunu çağırmak
için karakteri öncelikle çok-baytlı karakter dizisinden geniş karakter'e
çevirmek gerekiyor. <BR>
<BR>
Aslen tüm büyük/küçük harf dönüşümlerinin geniş karakterler üzerinden
yapılması en ideal çözümken, yazılım geliştiriciler performans kaygıları
nedeni ile karakterin niteliğine göre dönüşüm fonksiyonunu seçmeyi
uygun görüyorlar. Fakat bu yöntem çoğu zaman (hemen hemen her zaman)
Türkçe yerelinde hatalı çalışan uygulamaları doğuruyor.<BR>
<BR>
<!--TOC subsection Sorun: Aynı bellek alanında dönüşüm bellek alanını bozuyor-->

<H3><A NAME="htoc25">4.2</A>&nbsp;&nbsp;Sorun: Aynı bellek alanında dönüşüm bellek alanını bozuyor</H3><!--SEC END -->

Sorun i,I tek baytlı karakterlerinin İ,ı çok baytlı karakterlerine
dönüşümü sırasında meydana çıkıyor. Dönüşümü tek bir bellek alanı
(buffer) üzerinde gerçekleştirmeye çalışan yazılım i,I karakterleri
yerine yazılan İ,ı karakterlerinin son baytılarının bir sonraki karakterin
üzerine yazılmasına neden oluyor.<BR>
<BR>
Bu sorunun çözümü için dönüşümün yeni bir bellek alanı üzerinde yapılması
ve boyut değişimlerinde gerçek bellek alanının yeni boyuta (realloc)
uydurulması gerekiyor.<BR>
<BR>
<!--TOC subsection Sorun: Anahtar kelimelerin hatalı dönüşümü-->

<H3><A NAME="htoc26">4.3</A>&nbsp;&nbsp;Sorun: Anahtar kelimelerin hatalı dönüşümü</H3><!--SEC END -->

Bu son sorun genellikle, Türkçe karakter dönüşümlerini doğru olarak
yapabilen yeni/modern uygulamalarda ortaya çıkıyor. Uygulama imap,
quit gibi anahtar kelimelerini (keyword) Türkçe yerelinde İMAP, QUİT
karşılıklarına çeviriyor fakat dönüş değeri olarak İngilizce çevrimleri
IMAP ve QUIT'i bekliyor. Sonuç olarak anahtar kelimelerin karşılaştırmaları
hatalı sonuç veriyor.<BR>
<BR>
Çözüm olarak yalnızca anahtar kelimelerin dönüşümünde yerelin setlocale()
çağrısı ile C yereline çevrilmesi işe yarıyor.<BR>
<BR>
Özellikle bu son sorun için http://www.i18nguy.com/unicode/turkish-i18n.html
adresindeki belge gerekli açıklamayı yapıyor.
</div>
<!-- SAYFA İÇERİK SONU -->
        </div>
        <div id="footnote">
            <p>
              Information and documents on Pardus web pages can be used freely anywhere with original source credit.<br />
              For information and suggestion(s) please write to <a href="mailto:info%20at%20pardus.org.tr">info_at_pardus.org.tr</a><br />
              <em>TÜBİTAK - UEKAE, PK.74 41470, Gebze / Kocaeli.</em>
           </p>
        </div>
    </div>
</div>
<script src="http://www.google-analytics.com/urchin.js"
type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-420484-9";
urchinTracker();
</script>
</body>
</html>
